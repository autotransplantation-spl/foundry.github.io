\documentclass[a4paper,11pt]{letter}

\usepackage[utf8]{inputenc}

\usepackage{hyperref}
\usepackage{palatino}
\usepackage{color}

\usepackage{lipsum} % to generate some filler text
\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{soul}
\usepackage[normalem]{ulem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Comments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{ifthen}
\usepackage{amssymb}
\usepackage[switch]{lineno}%line number

\newboolean{showcomments}
\setboolean{showcomments}{true} % comment this line to deactivate comments
\ifthenelse{\boolean{showcomments}}{
  \newcommand{\nbc}[3]{
    {\colorbox{#3}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}%
    {\textcolor{#3}{\sf\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}}}
  \newcommand{\todo}[1]{\nbc{TODO}{#1}{blue}\xspace}
}{
  \newcommand{\nbc}[3]{}
  \newcommand{\todo}[1]{}
}
\newcommand{\eb}[1]{\nbc{Earl}{#1}{orange}}
\newcommand{\jp}[1]{\nbc{Justyna}{#1}{blue}}
\newcommand{\ls}[1]{\nbc{Leandro}{#1}{blue}}
\newcommand\re[1]{\nbc{To Review:}{#1}{green}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% End Comments %%%%%%%%%%%%%%%%%%%%%%%%%
% Margins
\topmargin=-0.75in
\textheight=9.55in
\oddsidemargin=0pt
\textwidth=6.6in

%\let\raggedleft\raggedright % Date on the left
\newcounter{reviewer}
\setcounter{reviewer}{0}
\newcounter{point}[reviewer]
\setcounter{point}{0}


% command declarations for reviewer points and our responses
\newcommand{\reviewersection}{\stepcounter{reviewer} \bigskip %\hrule
                  \section{\textbf{Response to Reviewer} \thereviewer}}
%%% Project Macros
\newcommand{\FOUNDRY}{\textsc{Foundry}\xspace}
\newcommand{\prodscalpel}{\textsc{prodScalpel}\xspace}
% This refines the format of how the reviewer/point reference will appear.
\renewcommand{\thepoint}{P\,\thereviewer.\arabic{point}} 
\newenvironment{point}
   {\refstepcounter{point} \bigskip \noindent {\textbf{Reviewer~Point~\thepoint} } ---\ }
   {\par }

\newcommand{\shortpoint}[1]{\refstepcounter{point}  \bigskip \noindent 
	{\textbf{Reviewer~Point~\thepoint} } ---~#1\par }

\newcommand{\shortreply}[2][]{\medskip \noindent \begin{sf}\textbf{Reply}:\  #2
	\ifthenelse{\equal{#1}{}}{}{ \hfill \footnotesize (#1)}%
	\medskip \end{sf}}

\newcommand{\bluetext}[1]{\begingroup\color{black}#1\endgroup}
\newcommand{\response}[1]{\textbf{Response:} \begingroup\color{black}#1\endgroup}
\newcommand{\perhaps}[1]{\begingroup\color{magenta}#1\endgroup}
\newcommand{\changes}[1]{\textbf{Changes to the paper:} \begingroup\color{blue}#1\endgroup}

% Abbreviations
\newcommand{\ie}{\hbox{\emph{i.e.}}\xspace}

\signature{\bluetext{\mbox{Leandro Souza}}}

\begin{document}

\begin{letter}{\textbf{Response to Reviewers' Comments}}

  \opening{\bluetext{Dear Editor,}}

  \bluetext{%
    Please find enclosed our response to the reviewers of our paper entitled
    ``Software Product Line Engineering via Software Transplantation'', \#TOSEM-2023-0120.
    We would like to thank you for the opportunity you gave us to revise and submit the new version of our manuscript.
    We did our best to address the main issues, remarks, comments, and suggestions provided by the referees.
    They are discussed in detail below, and highlighted in \textcolor{blue}{blue} in the paper.
    We would also like to gratefully acknowledge the reviewers for their efforts and their valuable feedback to the paper.
    They highly contributed to improving the quality of the manuscript.

  }
  %\closing
\bluetext{With our best regards,}

  %\ps
\bluetext{Leandro Souza, Earl T. Barr, Justyna Petke, Eduardo S. Almeida and Paulo Anselmo M. S. Neto}

  \bluetext{(e-mail: \href{mailto:leandro.souza@ifba.edu.br}{leandro.souza@ifba.edu.br})}
  \bluetext{(e-mail: \href{mailto:leandro.souza@ifba.edu.br}{leandro.souza@ifba.edu.br})}

\newpage
% Begin a new reviewer section
\reviewersection

  \bluetext{%
    We would like to gratefully acknowledge the reviewer for his/her comments, remarks, and suggestions on the submitted paper.
    We did our best to address the main issues raised in the reviewer's comments.
    They are discussed below.
    Changes resulted from these comments are highlighted in \textcolor{blue}{blue} in the revised manuscript.
  }

%Reviewer Point P 1.1
\begin{point}
  The problem tackled with this work is challenging and one of the identified bottlenecks in the field of SPL.
This work proposes a quite complete solution that seems to perform well as shown by the evaluation.
I only have a few comments about this paper, which are more like questions I think than criticisms.
\end{point}

  \response{Thank you very much for this positive feedback.}

%[Insert Reviewer's  comment here]
  % Point one description 

%Reviewer Point P 1.2 ----------------------------------------------------
\begin{point}
Figure 1 shows a sequence of transplatations, which I agree is easy to represent for such kind of succession, but is the order really important? In my opinion, probably not, except maybe when analysing the underlying dependency graph? Could it be interesting to analyse the impact of this analysis on missed artefacts when using ProdScalpel? (maybe to relate to reusability in compilation)
	\label{pt:foo}
\end{point}

\response{Thank you for your valuable comment. Regarding the order of transplantations illustrated in Figure 1, we acknowledge that ProdScalpel is designed to be agnostic to the order, meaning it can work effectively with any sequence. However, it's pertinent to note that the choice of order can impact the dependencies between transplanted features, potentially affecting the overall structure and size of the generated substrate. 
}

\changes{We have added a discussion about the order of transplantations in Section 2, at 8th paragraph.}

%Reviewer Point P 1.3 ----------------------------------------------------
\begin{point}
Section 3.2, Page 9, "To overcome these issues Foundry introduces an organ-host wrapper. This layer is responsible for providing access to the organ from the target host. It is automatically constructed on demand, according to a given implantation point in the product base."+
when I saw this, I wonder whether Foundry would only produce wrappers to call new features and thus, would it be possible that the product line becomes polygot (in the sense that the wrapper may only be a call to "exec" for instance whatever the program called)? 
It is probably not as simple as that, but could it be a viable solution? What would be the impacts on the host system (in term of performance for instance)?
	\label{pt:foo}
\end{point}

\response{Thanks for your interesting observation. Your interpretation aligns with the intended purpose of the organ-host wrapper in Foundry, which was indeed idealized to facilitate the integration and execution of transplanted features within the target host. It acts as an intermediary layer responsible for providing access to the organ from the target host, and its construction is automated based on a specified implantation point in the product base. This flexibility aims to accommodate diverse features from different sources and streamline their integration into the product line.

As for the possibility of the product line becoming polyglot, the answer is yes. 
The organ-host wrapper can be designed to be versatile, enabling the calling of new features as different programs or executable in various languages. This flexibility is a deliberate design choice, aiming to accommodate diverse features from different sources and facilitate their integration into the product line.
Concerning the impact on the host system, adapting the process to a polyglot product line can introduce a level of indirection that may have performance implications, especially if external processes like "exec" are involved. Additionally, this would have direct impact on the GP algorithm that must be redesigned to handle different languages or execution environments. 

If the wrapper is responsible for integrating features with different languages or execution environments, there might be additional overhead associated with data conversion, interoperability, or adapting features to the host system's context. The overall performance of the product line can be affected. Features invoked through the wrapper may experience a delay compared to direct invocations, and this delay can accumulate if numerous features are called sequentially. It would be advisable to conduct performance evaluations and optimizations, such as minimizing unnecessary computations, employing efficient conversion strategies, and caching frequently used features, to ensure that the polyglot nature of the product line does not unduly compromise its efficiency. 
}

\changes{We have added this observation to Section 4.3, at 4th paragraph.} 

%Reviewer Point P 1.4 ----------------------------------------------------
\begin{point}
Section 4.1, page 12, "Figure 8 gives a example of a portion of code after prodScalpel cleaned up unused directives."
in the end, from what I can see from Figure 8, ProdScalpel is able to provide two output "partial source code", one to use when the feature is activated and the second one when it is not, when adding a new feature to the host. The choice between the two will depend on the new product to derive I assume. Is that correct?
	\label{pt:foo}
\end{point}

\response{Thank you for your insightful observation and question regarding Figure 8. To be more accurate, in the context of the donor preparation for the transplant, the choice between retaining or removing a portion of code surrounded by directives in the donor depends on the relevance of the code to the target organ. If the portion of code is used as a substrate to the organ and functions correctly, ProdScalpel retains the code in the donor, removing only its directives. Otherwise, it removes both the code and the directives that delimit it. Thus, the process illustrated in Figure 8 results in a clean donor codebase, which is important for providing an organ free of directives for the transplantation process.
}

\changes{We have added the explanation in Section 4.1, at 2nd paragraph.}

%Reviewer Point P 1.5 ----------------------------------------------------
\begin{point}
Section 5.2, page 15, when authors use VI and VIM both as donor and product base. Did authors took two different versions of VI (and VIM)? One with the desired feature and one without it. That could make sense to the why trying to transplant a feature to the same codebase. It could also be a maner to evaluate the tool. Is it able to provide the same code in the end than the original? How does it differ? Which tests pass or fail? etc.
	\label{pt:foo}
\end{point}

\response{We appreciate the reviewer's comment. We used VI and VIM both as donors and product bases, we used two different versions for each: one with the desired feature, as donor, and one without it, as host.

In our evaluation, ProdScalpel successfully replicated the original code with the transplanted feature, albeit with the addition of the organ-host wrapper. Tests carried out on the resulting code confirmed that the transplanted organ passed all acceptance tests, validating the successful integration of the feature into the original codebase.}

\changes{We have clarified the experimental setup in Section 5.3, at 4th paragraph.}

%Reviewer Point P 1.6 ----------------------------------------------------

\begin{point}
Section 5.3, page 16, when answering RQ2, I have the feeling that it lacks some in-depth analysis. From my understanding, I assume that some products cannot be run due to missed instructions or something else, but it is not discussed. The text only refers to documentation that is imprecise.
In addition, maybe RQ2 is expressed in a misleading way when put in light of the analysis. I was expected to get a taxonomy of different features that can or cannot be handled yet.

	\label{pt:foo}
\end{point}


\response{Thank you for your constructive feedback. We have revised RQ2 to better reflect the analysis conducted.
}

\changes{We have revised RQ2 to state: ``How effective is \prodscalpel~at productizing software?''}

%Reviewer Point P 1.7 ----------------------------------------------------

\begin{point}Section 2, Page 4, line 20 "a document viewer for multiple document formats that is part of GNOME, not not an editor." -> an additional "not" maybe it was a "but" in the first place.
\end{point}
\response{Thank you for bringing this to our attention. You are correct; it was indeed an error.} 

\changes{
The corrected sentence now reads: "a document viewer for multiple document formats that is part of GNOME, but not an editor."}

%Reviewer Point P 0.8 ----------------------------------------------------
\begin{point}Figure 3 mentions two products P and Q but no products are visible on the figure.
\end{point}
\response{Thank you for bringing this to our attention. We acknowledge the error in the figure reference and appreciate your diligence in reviewing the text. The description you cited indeed belongs to Figure 2, not Figure 3. This has been corrected in the new version of the paper.}

\changes{The figure description has been moved to Figure 2.}

%Reviewer Point P 0.9 ----------------------------------------------------
\begin{point}I wonder whether Figures 1, 2, and 3 somehow may be redundant. Could they be merged? Is it a necessity to keep all these 3? (at least 1 and 2 separated?)
\end{point}
\response{Thank you for your thoughtful consideration of Figures 1, 2, and 3. We believe that maintaining these three figures separately is important for providing a comprehensive understanding of our approach. Each figure serves a different purpose in elucidating different aspects of the approach.

Figure 1 is designed to emphasize the iterative and incremental nature of our approach, showcasing the dynamic and evolving characteristics of the process over time. This figure contributes to a clearer visualization of the overall progression.

In Figure 2, our goal is to illustrate how the concept of software transplantation is employed to introduce variabilities and commonalities into the product line. This figure plays a pivotal role in conveying the foundational idea behind our approach.

Lastly, Figure 3 is dedicated to detailing each stage of the domain engineering process as outlined in our approach. By breaking down the process into stages, this figure provides a more granular view, helping readers comprehend the sequence of tasks in our approach.

While we recognize that merging figures might be a consideration, we believe that keeping them separate enhances the clarity and depth of the exposition. The distinct focus of each figure contributes to a more comprehensive understanding of our approach.}

\newpage  
% Begin a new reviewer section
\reviewersection

  \bluetext{%
    We acknowledge the time and effort the reviewer spent reading and commenting on the submitted paper.
    We have done our best to address the main issues raised.
    They are discussed below.
    Changes resulted from these comments are highlighted in \textcolor{blue}{blue} in the revised manuscript.
  }
  
  
\begin{point}
 The paper is interesting in the sense that tries to find synergies between two separate areas (SC and SPLE) to improve the SPLE process. It is also interesting that the proposal has been implemented and evaluated. The writing is in general easy to follow and the paper is well structured. 
 \end{point}

\response{Thank you for the positive feedback.}

\begin{point}
The general proposal is not clear. There are important mismatches in the problem definition and the example. Without a clear problem definition, the solution is difficult to evaluate. 
\end{point}

\response{Apologies the description of our approach has not been fully clear to you. Please note we identified four problems in SPLE in the paragraph at line 36 in the Introduction, and specify how our approach addresses those in the paragraph at line 50. We have addressed your particular points of confusion as follows:
}

\begin{point} 
    In the abstract, you say that this proposal is to re-engineer existing product into a SPL. However, the motivating example and the solution does not fit well with this. In Section 2 you say that the GNOME team could be interested in offering an SPL of text editors. Then, you describe two other tools where you could take features from and "transplant"  it to a common code base generated from Gedit. This is confusing because when you are in an extractive SPL approach you have a set of products and you do not know from which one you should start building the code base for your SPL. 
\end{point}

\response{Firstly, we did not state in the abstract that we ``re-enginer existing product into a SPL'', but that we ``re-engineer a codebase to support SPL''. Secondly, we would like to provide further clarification on the motivating example and the selection of Gedit as the base for our SPL generation proposal via software transplantation.

It’s important to emphasize that the choice of Gedit as the product base was made for illustrative purposes, and any other text editor could be employed to generate a different product line. Our intention with the motivating example was to illustrate an
extractive SPL process of text editors, demonstrating that new product lines can be generated through the reengineering process by transplanting features from different systems into a common product base, GEdit. 

Regarding the choice of GEdit as the product base in our example, it is important to note that our proposal does not dictate a fixed starting point for the product base. Instead, the choice of the initial product base is a pragmatic decision based on various factors such as the number of features required for the target product line that are already present in the host system candidate.

To address the reviewer’s concern about the apparent lack of a family of systems managed by the same organization, we want to clarify that Gedit, Evince, and Nedit are indeed individual systems, not part of a cohesive family managed by a single organization. In the case of Evince, while it shares some common features with Gedit, the example suggests the transplantation of a feature not present in Gedit, highlighting one of the main strengths of our approach -- we can transplant features from multiple codebases.
}

%\changes{\jp{We have further clarified that .. Leandro - please expand so that the above clarifications also end up in the manuscript, thank you.} 
\changes{We have further clarified that in Section 2, at 1st, 2nd and 3rd paragraphs.}}


\begin{point} 
The example seems to be more on "copying" features from other products rather than re-engineering an existing SPL. 
\end{point}

\response{We appreciate the reviewer's observation and would like to clarify that the perceived focus on 'copying' features might be a misinterpretation, and we would like to emphasize that our proposal involves a novel solution for re-engineering existing systems into Software Product Lines (SPLs) through the concept of software transplantation.

Our focus is on transitioning to SPL and then maintaining that SPL, not re-engineering an existing SPL, as we state in our abstract and in the 5th paragraph of the Introduction, at line 50.  
Of course, we "copy" and then adapt features into a product, as is standard. 
The challenge lies in identifying, minimally extracting, and adapting such features to create new products (see, for instance: Wesley K. G. Assunção, Roberto Erick Lopez-Herrejon, Lukas Linsbauer, Silvia R. Vergilio, and Alexander Egyed. 2017. Reengineering legacy 868 applications into software product lines: a systematic mapping. Empirical Software Engineering 22 (2017), 2972–3016.). 
Our core contribution is precisely that we allow extracting and using features from code 
that is not officially participating in the SPL, and can even be unaware of the SPL, like 
features extracted from open source projects.

In traditional SPL development, the emphasis is on creating a common codebase from scratch or adapting an existing system to meet the requirements of a product line. Our proposal takes a different route by introducing the concept of 'software transplantation,' a method that goes beyond mere copying of features.

The transplantation process involves extracting features from existing systems (donors) and integrating them into a common product base, demonstrating a transformative approach to SPL reengineering. This method allows for the strategic selection of features from diverse sources, providing an automated way to construct product lines.

Unlike conventional SPL methods that may involve extensive modification or rewriting of code, our approach minimizes the need for extensive redevelopment. It leverages existing functionality from various systems, enabling the creation of product lines with reduced effort and increased adaptability.

Our proposal represents a departure from traditional SPL practices, offering an automated solution that amalgamates features from different systems into a cohesive and adaptable product line. We hope this clarification highlights the innovative nature of our approach and its distinction from a simple 'copying' of features.}

\changes{We have clarified this point in Section 1 and 4.}

\begin{point} 
Also, you present in Fig. 1 the donors and the  host using a feature model. Are they already SPLs according to that? Are you re-engineering an SPL from existing SPLs? 
\end{point}

\response{We appreciate the reviewer's observation and would like to clarify the role of the feature model in our presentation, particularly in Figure 1. The use of a feature model is intended for feature representation and organization rather than implying that the depicted systems are already SPLs -- they are not.

In our proposal, the feature model serves as a visual representation to help SPL engineer to manage and understand the features available to the software transplantation process. It provides a structured view of the features that can be extracted from donor systems and how they can be integrated into the common product base.

The feature model does not presuppose that the depicted systems are inherently SPLs. Instead, it aids in illustrating the relationships and dependencies among features, facilitating the decision-making process during the transplantation.

Our proposal focuses on the reengineering of existing systems into SPLs through the software transplantation concept. The feature model is a tool in this process, offering a convenient way to organize and visualize features. We hope this clarification addresses the concern.}

\changes{We have now provided further clarification in Section 2, at 7th paragraph, as follows: 

"Importantly, the donor systems in this context are not product lines; we are using feature models to map some of their features, making it easier to understand what has been extracted from the donors' codebase."}

%\response{We appreciate the reviewer's question and would like to clarify the objective and nature of our proposal, especially concerning the motivating example and the choice of systems for reengineering.

%Our approach, as presented in the motivating example with \FOUNDRY, is centered around the reengineering of individual systems into Software Product Lines (SPLs). The goal is to facilitate the extraction and transplantation of features from diverse sources, creating a unified product line that combines functionalities from different individual systems.

%We believe that this approach, rooted in the software transplantation paradigm, presents a novel solution for SPL generation by leveraging existing codebases, irrespective of whether they belong to a portifolio of systems managed by the same organization or are individual products that does not share common features.

%We hope this clarification addresses the concerns raised by the reviewer, and we remain open to further discussions to enhance the clarity of our proposal}

%\jp{..till here}

\begin{point} 
Also, it is confusing in the example that you talk about three editors (gedit, evince and nedit). However, in the introduction you say that for evaluating your proposal you used other text editors (kilo, vi and cflow on top of vi and vim). This is confusing and distracts the reader. 
\end{point}

\response{The motivating example is more demonstrative and serves as a conceptual illustration of \FOUNDRY's potential. The motivating example featuring \emph{GEdit, Evince, and NEdit} is intended to provide a broad, illustrative view of \FOUNDRY's capabilities. It aims to show how the proposed approach can be applied to diverse systems, not necessarily the ones used in the formal evaluation.

The text editors (\emph{Kilo, VI, CFlow, VI, and VIM}) mentioned in the introduction are part of a focused set chosen specifically for the formal evaluation. The formal evaluation with specific text editors is designed for a more focused and detailed examination of the transplantation viability and ProdScalpel's performance. These editors were selected based on certain criteria such as  complexity, size and number of features, to rigorously test and demonstrate the effectiveness of \FOUNDRY.}

\changes{We have further clarified the criteria used in our choices for evaluation in Section 5.2, at 1st to 7th paragraphs.}

\begin{point} 
2) The solution is weakly presented. The difference between "foundary" and "prodscalpel" is confusing. After some reads, one can understand that one if the conceptual and the other is the implementation. However, this should be cleared right from the beginning. 
\end{point}

\response{We appreciate the reviewer's feedback regarding the clarity of our solution, specifically the distinction between "Foundry" and "ProdScalpel." We acknowledge the importance of clearly articulating their roles from the outset.

Foundry is the software transplantation approach we propose for the reengineering of individual systems into Software Product Lines (SPLs). It represents the conceptual framework and methodology for systematically extracting, adapting, and combining features from diverse sources to create a product line.

On the other hand, ProdScalpel is the practical realization of Foundry. It is the tool designed to implement and automate the steps outlined by Foundry. ProdScalpel serves as the operational instrument, facilitating the extraction of features from donor systems, their adaptation to fit the host system, and the subsequent generation of a product line.

To provide a clearer narrative, we enhanced the introduction by explicitly introducing Foundry as the software transplantation approach and ProdScalpel as the tool that operationalizes this approach. This clarification aims to eliminate any confusion regarding their respective roles and establish a better understanding for readers.}

\changes{We have introduced the following sentence in Section 1, at 9th paragraph, to better clarify the idea of Foundry and ProdScalpel.:

``Foundry is the conceptual solution for the reengineering of individual systems into SPL, while ProdScalpel is one possible implementation designed to automate the steps outlined by Foundry. As the practical counterpart to Foundry's conceptual underpinnings, Prodscalpel bridges the gap between theory and implementation.''}

\begin{point} 
Section 3 is not formally or rigorously described. There is no a single definition along the sections and only descriptive paragraphs are used. (..)
The solution is described in a vague way. A more theoretical or at least rigorous approach should be followed to describe the solution. 
\end{point}

\response{Thank you for your feedback. The primary objective of our paper is to present and describe our approach, along with the automation details through ProdScalpel. We intentionally focused on providing a comprehensive understanding of the software transplantation process for SPL re-engineering, emphasizing practical insights.

We would like to draw your attention to the fact that the transplantation process itself has been formally defined in our previous work titled "Automated Software Transplantation" ( reference 4 from the paper), which we mention in Introduction, paragraph 4 and Section 4, paragraph 1. In this paper, we aimed to bridge the conceptual understanding from the transplantation paper with the practical implementation presented here. Our intention was to balance theoretical foundation with practical insights to make the approach both conceptually clear and practically applicable in the context to the SPL reengineering. }

\begin{point} 
Why in Figure 2 system 4 is selected? why P and Q are the "code base" and feature N and O are removed? P and Q are not features that are shared with other systems, are they?
\end{point}

\response{Thank you for your observation. In Figure 2, the representation of features P, Q, N, and O are integral to illustrating the variability in the product line. These features are extracted from 3 donors systems into the product line and then implanted into the products that require each one of them. Features N and O signify features that are removed during the transplantation process, as they are deemed non-essential or irrelevant to the target product line or the derived products. On the other hand, features P and Q are retained in the product base and shared among the products in the product line. As a result, the product line includes features B, F, H, J, P, and Q, enabling the generation of diverse products through the software transplantation process.

To enhance the clarity of this aspect of the figure, we have included a paragraph providing detailed explanations for each component, aiming to ensure a more comprehensive understanding for readers. We appreciate your feedback and believe that these additional clarifications will address your concern.}

\changes{We have added the following clarifications in figure description and detail it in the Section 3,  at 3rd and 4th paragraphs:

"Figure 2 illustrates the concept under discussion. In the first part of the figure, we identify three donor systems from which features are transplanted into a codebase. The representation of features B, F, H, and J serves to demonstrate the inherent variability in the product line. These features are extracted into the product line and subsequently implanted into specific products according to their requirements.

In the second part of the figure, we have a product base generated from a host system. The features N and O in the host system symbolize elements that need to be removed during the transplantation process due to their irrelevance to the target product line or the resulting products. Features P and Q exemplify the commonality within the product line, as they will be kept in the product base and shared among multiple products. As a result, we have a product line comprising features B, F, H, J, P, and Q, enabling the generation of diverse products through the software transplantation process."}

\begin{point} 
In addition, the implementation is described as a tool paper and adds no value to rigorously and clearly present your approach/tool. 
\end{point}

\response{Thank you for your feedback. While we appreciate your perspective, we respectfully disagree with the notion that our implementation is purely a tool paper and lacks value in presenting our approach rigorously and clearly. In Section 4, we have made a deliberate effort to provide detailed insights into the implementation details of our tool, ProdScalpel. This includes how each stage of the transplantation process is automated and the strategies employed to address various challenges. By presenting the tool implementation, we aim to bridge the gap between theory and practice, offering a tangible demonstration of the concepts detailed in Section 3.

Moreover, the implementation details serve as a practical guide for researchers and practitioners interested in adopting our approach. The tool paper aspect complements the theoretical foundation provided in Section 3, contributing to the reproducibility and applicability of our approach in real-world scenarios. We believe that a comprehensive understanding of both the conceptual framework and its practical realization is essential for the successful adoption and adaptation of our approach in the broader software engineering community.}

\begin{point} 
- The title is confusing. It seems that the paper is more about "feature extraction and implantation using software transplantation" and it is not much about SPLE
\end{point}

\response{Thank you for your feedback. We would like to provide some clarification on your perspective on the title. While the the paper may emphasize the aspect of "feature extraction and implantation using software transplantation," it is important to recognize that our primary focus is on Software Product Line Engineering (SPLE) using software transplantation.

The term "feature extraction and implantation" is a fundamental component of our SPLE approach, where FOUNDRY employs software transplantation to systematically extract, adapt, and combine features from diverse sources to construct a product line. In essence, our research explores the intersection of software transplantation and SPLE, proposing a novel approach to SPL generation through automated reengineering.

The title aims to convey the integration of these two areas, emphasizing the unique contribution of software transplantation to SPLE. We believe that our approach, as presented in the paper, provides valuable insights into how software transplantation can be applied to enhance SPLE processes, addressing challenges related to maintainability, feature separation, and code duplication.

We hope this clarification helps in understanding the overarching theme of our research and its significance in the context of SPLE using software transplantation.}

\begin{point} 
In the abstract, the ideas are not clear. More details should be given. What is your solution about? In what is based? Only high level descriptions are given.
\end{point}

\response{Thank you for your feedback. Based on your comments, we have revised the abstract to provide more clarity on our solution. The abstract now offers additional details regarding the nature of our solution, focusing on \FOUNDRY's role in automating SPL processes through software transplantation. We have elaborated on the core concept of software transplantation and how it forms the foundation for \FOUNDRY's structured and automated approach to feature extraction and migration in SPLs. We hope these enhancements address your concerns and offer a clearer understanding of the paper's contributions.}

\changes{ The abstract now reads:

``Software Product Lines (SPLs) offer substantial benefits for companies producing related products by improving time-to-market, enhancing software quality, and reducing costs.  However, implementing SPL practices involves lengthy re-engineering and ongoing maintenance challenges. Current SPL practices rely on a suite of tools, each tailored for specific reengineering phases, leading to coordination and integration complexities for developers.
To address these challenges, we introduce \FOUNDRY, an automated approach utilizing software transplantation to expedite SPL conversion and maintenance. \FOUNDRY's solution is rooted in the concept of software transplantation, a process involving the adaptation and incorporation of code segments from one system into another. Building upon this foundation, \FOUNDRY systematically applies software transplantation to SPL, providing a structured and automated approach. By understanding the intricacies of feature extraction and migration, \FOUNDRY enables the generation of SPLs with increased speed and efficiency, addressing the challenges associated with manual efforts.
We realise \FOUNDRY in \prodscalpel, a tool that transplants multiple organs (\ie, a set of interesting features) from donor systems into an emergent product line for codebases written in C. To evaluate its effectiveness, we conducted an experiment comparing feature transplantation using \prodscalpel with manual effort. Our tool successfully produced two valid product lines, automating feature extrastion and integration from three real-world systems. The achieved results reveal that \prodscalpel achieved an average of 4.8 times faster feature migration across codebases compared to a group of SPL experts. ''}

\newpage
\begin{point} 
Add a reference to support the first sentence of the 2nd paragraph of Section 1
\end{point}

\response{
Thank you for the suggestion. In response to your comment, we added three references to support the first sentence of the second paragraph in Section 1. 
Here is how each reference supports the first sentence:

Breivold (2008): The reference by Breivold, titled "Migrating Industrial Systems towards Software Product Lines: Experiences and Observations through Case Studies," provides insights into the challenges and experiences of adopting Software Product Lines in industrial systems. It contributes to the understanding that upfront investment is a significant aspect of SPL adoption.

Bastos (2017): The reference to Bastos' work on "Software Product Lines Adoption in Small Organizations" offers perspectives on SPL adoption in small organizations. It supports the notion that upfront investment is a common consideration, even in smaller organizational contexts, reinforcing the general applicability of the statement.

Daniel (2020): The reference by Daniel, titled "Economic Impact of Software Product Line Engineering Method - A Survey," provides insights into the economic impact of Software Product Line engineering methods through a survey. In the paper, Daniel emphasizes that although the adoption of an SPLE might have plenty of benefits for an organization, it also implies several challenges; among them is the need for an initial cost investment. This aligns with our statement about the upfront investment in SPL adoption.}


\changes{The revised sentence now reads:

``Despite its benefits, adopting SPL requires considerable upfront investment before its benefits can be realized (references 7, 11 and 16 from the paper).''}

\begin{point} 
The first time that prodscalpel is mentioned is in line 44 (pag 3 of 32) and it is confusing that it is. 
\end{point}

\response{Thank you for your feedback. To enhance clarity, we will make adjustments to the text, ensuring a smoother introduction of ProdScalpel earlier in the abstract. }

\changes{The abstract now contains the following sentence:

"By understanding the intricacies of feature extraction and migration, FOUNDRY enables the generation of SPLs with increased speed and efficiency, addressing the challenges associated with manual efforts. We realise FOUNDRY in PRODSCALPEL, a tool that transplants multiple organs (\ie, a set of interesting features) from donor systems into an emergent product line for codebases written in C."}

\begin{point} 
Fig 1 is in page 4 but the first mention to it is in pag 5 and in another section. This is confusing. 
\end{point}

\response{Thank you for bringing this to our attention. We acknowledge the confusion caused by the placement of Fig 1 in page 4 and its first mention on page 5 in a different section. We have addressed this concern by moving the image to the next page, ensuring that it aligns with its first mention.}

\changes{The figure has been moved to the next page.}

\begin{point} 
Foundary is described as "an approach" (l 29 p 4). It would be nice to more precisely describe it: process? methodology fragment? tool? what?
\end{point}

\response{Thank you for your feedback. Foundry is the conceptual solution for the reengineering of individual systems into Software Product Lines (SPLs), while ProdScalpel is just one possible implementation designed to automate the steps outlined by Foundry.}

\changes{We have introduced the following sentence in Section 1, at 9th paragraph, to better clarify the idea of Foundry and ProdScalpel. 

"Foundry is the conceptual solution for the reengineering of individual systems into SPL, while ProdScalpel is one possible implementation designed to automate the steps outlined by Foundry. As the practical counterpart to Foundry's conceptual underpinnings, Prodscalpel bridges the gap between theory and implementation."}

\begin{point} 
The statement that GNOME is a natural candidate for SPL is quite strong! (l 9, p5)
\end{point}
\response{Thank you for bringing this point to our attention. We recognize that the term "natural candidate" may convey a level of certainty that could be perceived as overly strong. In light of your suggestion, we have revised the statement to express a more nuanced perspective.
We hope this adjustment aligns better with the intended meaning.}

\changes{We omit the statement and rewrite the 1st, 2nd, and 3rd paragraphs of the "Motivating Example" section.}

\end{letter}
\end{document}
