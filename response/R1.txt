Referee: 1

Recommendation: Needs Minor Revision

Comments:
As I said before, the problem tackled with this work is challenging and one of the identified bottlenecks in the field of SPL.
This work proposes a quite complete solution that seems to perform well as shown by the evaluation.
I only have a few comments about this paper which are more like questions I think than criticisms.

Figure 1 shows a sequence of transplatations, which I agree is easy to represent for such kind of succession, but is the order really important? In my opinion, probably not, except maybe when analysing the underlying dependency graph? Could it be interesting to analyse the impact of this analysis on missed artefacts when using ProdScalpel? (maybe to relate to reusability in compilation)

Section 3.2, Page 9, "To overcome these issues Foundry introduces an organ-host wrapper. This layer is responsible for providing access to the organ from the target host. It is automatically constructed on demand, according to a given implantation point in the product base."
when I saw this, I wonder whether Foundry would only produce wrappers to call new features and thus, would it be possible that the product line becomes polygot (in the sense that the wrapper may only be a call to "exec" for instance whatever the program called)? 
It is probably not as simple as that, but could it be a viable solution? What would be the impacts on the host system (in term of performance for instance)?

Section 4.1, page 12, "Figure 8 gives a example of a portion of code after prodScalpel cleaned up unused directives."
in the end, from what I can see from Figure 8, ProdScalpel is able to provide two output "partial source code", one to use when the feature is activated and the second one when it is not, when adding a new feature to the host. The choice between the two will depend on the new product to derive I assume. Is that correct?

Section 5.2, page 15, when authors use VI and VIM both as donor and product base. Did authors took two different versions of VI (and VIM)? One with the desired feature and one without it. That could make sense to the why trying to transplant a feature to the same codebase. It could also be a maner to evaluate the tool. Is it able to provide the same code in the end than the original? How does it differ? Which tests pass or fail? etc.

Section 5.3, page 16, when answering RQ2, I have the feeling that it lacks some in-depth analysis. From my understanding, I assume that some products cannot be run due to missed instructions or something else, but it is not discussed. The text only refers to documentation that is imprecise.
In addition, maybe RQ2 is expressed in a misleading way when put in light of the analysis. I was expected to get a taxonomy of different features that can or cannot be handled yet.

MINOR:
 - Section 2, Page 4, line 20 "a document viewer for multiple document formats that is part of GNOME, not not an editor." -> an additional "not" maybe it was a "but" in the first place.

 - Figure 3 mentions two products P and Q but no products are visible on the figure.

- I wonder whether Figures 1, 2, and 3 somehow may be redundant. Could they be merged? Is it a necessity to keep all these 3? (at least 1 and 2 separated?)

Additional Questions:
Review's recommendation for paper type: Full length technical paper

Does this paper present innovative ideas or material?: Yes

In what ways does this paper advance the field?: This paper proposes a tool and describes a methodology toward software (and feature) transplation for SPLs which is a very challenging topic and not fully addressed in the litterature.

Is the information in the paper sound, factual, and accurate?: Yes

If not, please explain why.: 

Rate the paper on its contribution to the body of knowledge in software engineering (none=1, very important=5): 5

What are the major contributions of the paper?: This work describes Foundry in the first place. It is a tool that allows for feature transplatation from one codebase to another with re-engineering. This way, the transplated codebase (the host) can use the feature coming from the donor. This approach is particularly challenging in the context of SPLs since the feature can be spread among different artefact and the hosted SPL can still be capable of introduce the feature correctly in its codebase.
Secondly, the paper proposes an implementation in C of Foundry, named ProdScalpel which is evaluated.

Rate how well the ideas are presented (very difficult to understand=1, very easy to understand=5): 4

Rate the overall quality of the writing (very poor=1, excellent=5): 5

Does this paper cite and use appropriate references?: Yes

If not, what important references are missing?: 

Should anything be deleted from or condensed in the paper?: No

If so, please explain.: 

Is the treatment of the subject complete?: Yes

If not, What important details / ideas/ analyses are missing?: 

If this is a Journal-First Paper, does it differ by more than 70% from any other previous publication?: 

Comments: 

Please help ACM create a more efficient time-to-publication process: Using your best judgment, what amount of copy editing do you think this paper needs?: Light

Most ACM journal papers are researcher-oriented. Is this paper of potential interest to developers and engineers?: Yes

