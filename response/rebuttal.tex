\documentclass[a4paper,11pt]{letter}

\usepackage[utf8]{inputenc}

\usepackage{hyperref}
\usepackage{palatino}
\usepackage{color}

\usepackage{lipsum} % to generate some filler text
\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{xspace}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Comments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{ifthen}

\newboolean{showcomments}
\setboolean{showcomments}{true} % comment this line to deactivate comments
\ifthenelse{\boolean{showcomments}}{
  \newcommand{\nbc}[3]{
    {\colorbox{#3}{\bfseries\sffamily\scriptsize\textcolor{white}{#1}}}%
    {\textcolor{#3}{\sf\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}}}
  \newcommand{\todo}[1]{\nbc{TODO}{#1}{blue}\xspace}
}{
  \newcommand{\nbc}[3]{}
  \newcommand{\todo}[1]{}
}
\newcommand{\eb}[1]{\nbc{Earl}{#1}{orange}}
\newcommand{\jp}[1]{\nbc{Justyna}{#1}{blue}}
\newcommand{\ls}[1]{\nbc{Leandro}{#1}{blue}}
\newcommand\re[1]{\nbc{To Review:}{#1}{green}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% End Comments %%%%%%%%%%%%%%%%%%%%%%%%%
% Margins
\topmargin=-0.75in
\textheight=9.55in
\oddsidemargin=0pt
\textwidth=6.6in

%\let\raggedleft\raggedright % Date on the left
\newcounter{reviewer}
\setcounter{reviewer}{0}
\newcounter{point}[reviewer]
\setcounter{point}{0}


%%% Project Macros
\newcommand{\FOUNDRY}{\textsc{Foundry}\xspace}
\newcommand{\prodscalpel}{\textsc{prodScalpel}\xspace}
% This refines the format of how the reviewer/point reference will appear.
\renewcommand{\thepoint}{P\,\thereviewer.\arabic{point}} 
\newenvironment{point}
   {\refstepcounter{point} \bigskip \noindent {\textbf{Reviewer~Point~\thepoint} } ---\ }
   {\par }

\newcommand{\shortpoint}[1]{\refstepcounter{point}  \bigskip \noindent 
	{\textbf{Reviewer~Point~\thepoint} } ---~#1\par }

\newcommand{\shortreply}[2][]{\medskip \noindent \begin{sf}\textbf{Reply}:\  #2
	\ifthenelse{\equal{#1}{}}{}{ \hfill \footnotesize (#1)}%
	\medskip \end{sf}}

\newcommand{\bluetext}[1]{\begingroup\color{black}#1\endgroup}
\newcommand{\response}[1]{\textbf{Response:} \begingroup\color{black}#1\endgroup}
\newcommand{\perhaps}[1]{\begingroup\color{magenta}#1\endgroup}
\newcommand{\changes}[1]{\textbf{Changes to the paper:} \begingroup\color{blue}#1\endgroup}

\signature{\bluetext{\mbox{Leandro Souza}}}

\begin{document}

\begin{letter}{\textbf{Response to Reviewers' Comments}}

  \opening{\bluetext{Dear Editor,}}

  \bluetext{%
    Please find enclosed our response to the reviewers of our paper entitled
    ``Software Product Line Engineering via Software Transplantation TOSEM-2023-0120''.
    We would like to thank you for the opportunity you gave us to revise and submit the new version of our manuscript.
    We did our best to address the main issues, remarks, comments, and suggestions provided by the referees.
    They are discussed in detail below, and highlighted in blue in the paper.
    We would also like to gratefully acknowledge the reviewers for their efforts and their valuable feedback to the paper.
    They highly contributed to improving the quality of the manuscript.

  }
  %\closing
\bluetext{With our best regards,}

  %\ps
\bluetext{Leandro Souza}

  \bluetext{(e-mail: \href{mailto:leandro.souza@ifba.edu.br}{leandro.souza@ifba.edu.br})}

  \noindent\rule{\textwidth}{0.4pt}

  \textbf{Reviewer \#1:}

  \bluetext{%
    We would like to gratefully acknowledge the reviewer for his/her comments, remarks, and suggestions on the submitted paper.
    We did our best to address the main issues raised in the reviewer's comments.
    They are discussed below.
  }

  [Insert Reviewer's positiver comments here]

  \response{Thank you very much for this positive feedback.}

%[Insert Reviewer's  comment here]
  % Point one description 
\begin{point}
Figure 1 shows a sequence of transplatations, which I agree is easy to represent for such kind of succession, but is the order really important? In my opinion, probably not, except maybe when analysing the underlying dependency graph? Could it be interesting to analyse the impact of this analysis on missed artefacts when using ProdScalpel? (maybe to relate to reusability in compilation)
	\label{pt:foo}
\end{point}

\response{Thank you for your valuable comment. Regarding the order of transplantations illustrated in Figure 1, we acknowledge that ProdScalpel is designed to be agnostic to the order, meaning it can work effectively with any sequence. However, it's pertinent to note that different orders may influence the resulting substrate's compactness. The choice of order can impact the dependencies between transplanted features, potentially affecting the overall structure and size of the generated substrate. Analyzing the underlying dependency graph in various orders could indeed provide insights into optimizing the compactness of the substrate, and we appreciate your suggestion to explore this aspect further.

We agree that investigating the impact of transplantation order on missed artifacts, especially concerning the underlying dependency graph, could be an interesting avenue for future research. This analysis could contribute to a more comprehensive understanding of how ProdScalpel operates in different scenarios and its implications for reusability in compilation processes. We will consider incorporating this aspect into our evaluation to enhance the robustness and applicability of ProdScalpel. Thank you for highlighting this potential avenue for improvement and analysis.}

\changes{}


\begin{point}
Section 3.2, Page 9, "To overcome these issues Foundry introduces an organ-host wrapper. This layer is responsible for providing access to the organ from the target host. It is automatically constructed on demand, according to a given implantation point in the product base."+
when I saw this, I wonder whether Foundry would only produce wrappers to call new features and thus, would it be possible that the product line becomes polygot (in the sense that the wrapper may only be a call to "exec" for instance whatever the program called)? 
It is probably not as simple as that, but could it be a viable solution? What would be the impacts on the host system (in term of performance for instance)?
	\label{pt:foo}
\end{point}

\response{Thanks for your interesting contribution. Your interpretation aligns with the intended purpose of the organ-host wrapper in Foundry. The wrapper was indeed idealized to facilitate the integration and execution of transplanted features within the target host. It acts as an intermediary layer responsible for providing access to the organ from the target host, and its construction is automated based on a specified implantation point in the product base. This flexibility aims to accommodate diverse features from different sources and streamline their integration into the product line.

As for the possibility of the product line becoming polyglot, the answer is affirmative. The organ-host wrapper can designed to be versatile., enabling the calling of new features as different programs or executable in various languages. This flexibility is a deliberate design choice, aiming to accommodate diverse features from different sources and facilitate their integration into the product line.

Concerning the impacts on the host system, adapt the process to a polyglot product line, can introduce a level of indirection that may have performance implications, especially if external processes like "exec" are involved. Additionally, this would have direct impact the GP algorithm that must be redesigned to handle with different languages or execution environments. 

If the wrapper is responsible for integrating features with different languages or execution environments, there might be additional overhead associated with data conversion, interoperability, or adapting features to the host system's context. The overall runtime performance of the product line may be affected. Features invoked through the wrapper may experience a delay compared to direct invocations, and this delay can accumulate if numerous features are called sequentially. It would be advisable to conduct performance evaluations and optimizations to ensure that the polyglot nature of the product line does not unduly compromise its efficiency. Additionally, the specific impacts would depend on the nature and complexity of the transplanted features and the execution environment.

To mitigate potential performance impacts, careful consideration of the wrapper's design and implementation is important. Performance optimizations, such as minimizing unnecessary computations, employing efficient conversion strategies, and caching frequently used features, are essential for enhancing the overall responsiveness of the polyglot product line.}

\changes{}

\begin{point}
Section 4.1, page 12, "Figure 8 gives a example of a portion of code after prodScalpel cleaned up unused directives."
in the end, from what I can see from Figure 8, ProdScalpel is able to provide two output "partial source code", one to use when the feature is activated and the second one when it is not, when adding a new feature to the host. The choice between the two will depend on the new product to derive I assume. Is that correct?
	\label{pt:foo}
\end{point}

\response{Thank you for your insightful observation and question regarding Figure 8. In fact in the context of the donor preparation to the transplant, the choice between retain or remove a portion of code surrounded by directives in the donor depends on the relevance of the code to the target organ. If the portion of code are used as a substract to the organ correctly works, ProdScalpel retain the code in the donor removing only its directives. Otherwise, it remove both code and directives that delimite it. Thus, the process illustrated in Figure 8 results in a clean donor codebase, important for providing an organ free of directives for the transplantation process. 

It is important notes that, in the context of host preparation, the choice between keep or remove the features from the product base depends on the target product line. In this case, the reconfiguratior is used clean the host codebase aims to proide a product base free of features not relevants to the resulting product line.

We appreciate your attention to this aspect of ProdScalpel's functionality and ensure that this distinction is now clearly articulated in the relevant sections of the manuscript.}

\changes{In the context of the donor preparation for the transplant, the choice between retaining or removing a portion of code surrounded by directives in the donor depends on the relevance of the code to the target organ. If the portion of code is used as a substrate for the organ to work correctly, ProdScalpel retains the code in the donor, removing only its directives. Otherwise, it removes both the code and directives that delimit it. Thus, the process illustrated in Figure 8 results in a clean donor codebase, important for providing an organ free of directives for the transplantation process.

It is important to note that, in the context of host preparation, the choice between keeping or removing features from the product base depends on the target product line. In this case, the reconfigurator is used to clean the host codebase, aiming to provide a product base free of features not relevant to the resulting product line.}

\begin{point}
Section 5.2, page 15, when authors use VI and VIM both as donor and product base. Did authors took two different versions of VI (and VIM)? One with the desired feature and one without it. That could make sense to the why trying to transplant a feature to the same codebase. It could also be a maner to evaluate the tool. Is it able to provide the same code in the end than the original? How does it differ? Which tests pass or fail? etc.
	\label{pt:foo}
\end{point}
\ls{Dear Justyna and Earl, I don't have the analysis required to answer his questions. I can analise the code and run the tests to answer he if you think important to do it.}

\response{}

\changes{}

\begin{point}
Section 5.3, page 16, when answering RQ2, I have the feeling that it lacks some in-depth analysis. From my understanding, I assume that some products cannot be run due to missed instructions or something else, but it is not discussed. The text only refers to documentation that is imprecise.
In addition, maybe RQ2 is expressed in a misleading way when put in light of the analysis. I was expected to get a taxonomy of different features that can or cannot be handled yet.

	\label{pt:foo}
\end{point}

\ls{Justyna and Earl, in Section 5.3, we provide an overview of the case studies. However, to address the reviewer's suggestion for a more in-depth analysis and a taxonomy of features, we need to enhance the discussion regarding the characteristics of features that prodScalpel can handle and those with which it faces challenges. Achieving this is currently not possible with the data we have. To do so, I would need to attempt transplanting all features from VIM, categorizing them based on complexity, dependencies, or other relevant criteria. This would allow us to explicitly mention any products that couldn't be run due to missed instructions and discuss the reasons behind such cases, providing a more comprehensive understanding of prodScalpel's capabilities and limitations. For the moment, I can explicitly state the limitations posed by the technologies used in prodScalpel, such as Doxygen and TXL, based on features not productized, like SPELL\_CHECK. I will also discuss potential avenues for future improvement and research to overcome these limitations. Do you think that this would be enough to answer the comment or not?}

\response{}

\changes{}


\textbf{Minor review}

\begin{point}Section 2, Page 4, line 20 "a document viewer for multiple document formats that is part of GNOME, not not an editor." -> an additional "not" maybe it was a "but" in the first place.
\end{point}
\response{}

\changes{}

\begin{point}Figure 3 mentions two products P and Q but no products are visible on the figure.
\end{point}
\response{}

\changes{}

\begin{point}I wonder whether Figures 1, 2, and 3 somehow may be redundant. Could they be merged? Is it a necessity to keep all these 3? (at least 1 and 2 separated?)
\end{point}
\response{}

\changes{}

  \noindent\rule{\textwidth}{0.4pt}

  \textbf{Reviewer \#2:}

  \bluetext{%
    We would like to gratefully acknowledge the reviewer for his/her comments, remarks, and suggestions on the submitted paper.
    We did our best to address the main issues raised in the reviewer's comments.
    They are discussed below.
  }

  [Insert Reviewer's positiver comments here]

  \response{Thank you very much for this positive feedback.}

\begin{point}
The general proposal is not clear. There are important mismatches in the problem definition and the example. Without a clear problem definition, the solution is difficult to evaluate. 
\end{point}

\response{}

\changes{}

\begin{point} 
2) The solution is described in a vague way. A more theoretical or at least rigorous approach should be followed to describe the solution. The solution seems to be more like a white paper for a tool than a research paper with reproducible elements. 
\end{point}

\response{}

\changes{}

\begin{point} 
    In the abstract, you say that this proposal is to re-engineer existing product into a SPL. However, the motivating example and the solution does not fit well with this. In Section 2 you say that the GNOME team could be interested in offering an SPL of text editors. Then, you describe two other tools where you could take features from and "transplant"  it to a common code base generated from Gedit. This is confusing because when you are in an extractive SPL approach you have a set of products and you do not know from which one you should start building the code base for your SPL. 
\end{point}

\response{We appreciate the reviewer's comment and would like to provide further clarification on the motivating example and the selection of Gedit as the base for our SPL generation proposal via software transplantation.

Our intention with the motivating example was to illustrate an extractive SPL process, demonstrating that new product lines can be generated through the reengineering process by transplanting features from different systems into a common product base. Gedit was chosen as a base due to its availability and suitability for showcasing the proposed approach. The decision to use Gedit is arbitrary, and we acknowledge that other text editors like Evince and Nedit could be equally valid choices.

Regarding the choice of \emph{GEdit} as the product base in our example, it is important to note that our proposal does not dictate a fixed starting point for the codebase. Instead, the choice of the initial product base (\emph{GEdit} in this case) is a pragmatic decision based on various factors, including the number of features required for the target product line already present in the host system candidate. The choice of \emph{GEdit} in the example is not prescriptive; other text editors like \emph{VIM}, \emph{VI} or \emph{NEdit} could have been chosen based on the project requirements. 

To address the reviewer's concern about the apparent lack of a family of systems managed by the same organization, we want to clarify that Gedit, Evince, and Nedit are indeed individual systems, not part of a cohesive family managed by a single organization. In the case of Evince, while it shares some common features with Gedit, the example suggests the transplantation of a feature not present in Gedit, highlighting the flexibility of the proposed approach.

It's crucial to emphasize that the choice of Gedit as the product base was made for illustrative purposes, and any other text editor could be employed to generate a different product line. The decision might be influenced by factors such as the number of features required for the target product line that are already present in the host system candidate. The key takeaway is the demonstrated capability to construct SPLs by strategically selecting a product base and extracting features from diverse donor systems.

We hope this clarification addresses the concerns raised by the reviewer and underscores the flexibility inherent in our SPL generation approach.}

\changes{}

\begin{point} 
The example seems to be more on "copying" features from other products rather than re-engineering an existing SPL. 
\end{point}

\response{We appreciate the reviewer's engagement with our proposal and the opportunity to clarify the essence of our approach. The perceived focus on 'copying' features might be a misinterpretation, and we would like to emphasize that our proposal involves a novel solution for reengineering existing systems into Software Product Lines (SPLs) through the innovative concept of software transplantation.

In traditional SPL development, the emphasis is on creating a common codebase from scratch or adapting an existing system to meet the requirements of a product line. Our proposal takes a different route by introducing the concept of 'software transplantation,' a method that goes beyond mere copying of features.

The transplantation process involves extracting features from existing systems (donors) and integrating them into a common product base, demonstrating a transformative approach to SPL reengineering. This method allows for the strategic selection of features from diverse sources, providing an automated way to construct product lines.

Unlike conventional SPL methods that may involve extensive modification or rewriting of code, our approach minimizes the need for extensive redevelopment. It leverages existing functionality from various systems, enabling the creation of product lines with reduced effort and increased adaptability.

Our proposal represents a departure from traditional SPL practices, offering a automated solution that amalgamates features from different systems into a cohesive and adaptable product line. We hope this clarification highlights the innovative nature of our approach and its distinction from a simple 'copying' of features.}

\changes{}

\begin{point} 
Also, you present in Fig. 1 the donors and the  host using a feature model. Are they already SPLs according to that? 
\end{point}

\response{We appreciate the reviewer's observation and would like to clarify the role of the feature model in our presentation, particularly in Figure 1. The use of a feature model is intended for feature representation and organization rather than implying that the depicted systems are already SPLs.

In our proposal, the feature model serves as a visual representation to help SPL engineer to manage and understand the features evailable to the software transplantation process. It provides a structured view of the features that can be extracted from donor systems and how they can be integrated into the common product base.

The feature model does not presuppose that the depicted systems are inherently SPLs. Instead, it aids in illustrating the relationships and dependencies among features, facilitating the decision-making process during the transplantation.

Our proposal focuses on the reengineering of existing systems into SPLs through the software transplantation concept. The feature model is a tool in this process, offering a convenient way to organize and visualize features. We hope this clarification addresses the concern, and we are open to further discussions or adjustments to enhance the clarity of our presentation.}

\changes{}

\begin{point} 
Are you re-engineering an SPL from existing SPLs? All this is confusing and makes it difficult to understand the problem you want to solve. The problem has to be very well explained so that the solution can be evaluated. 
\end{point}

\response{We appreciate the reviewer's question and would like to clarify the objective and nature of our proposal, especially concerning the motivating example and the choice of systems for reengineering.

Our approach, as presented in the motivating example with \FOUNDRY, is centered around the reengineering of individual systems into Software Product Lines (SPLs). The goal is to facilitate the extraction and transplantation of features from diverse sources, creating a unified product line that combines functionalities from different individual systems.

We believe that this approach, rooted in the software transplantation paradigm, presents a novel solution for SPL generation by leveraging existing codebases, irrespective of whether they belong to a portifolio of systems managed by the same organization or are individual products that does not share common features.

We hope this clarification addresses the concerns raised by the reviewer, and we remain open to further discussions to enhance the clarity of our proposal}

\changes{}

\begin{point} 
Also, it is confusing in the example that you talk about three editors (gedit, evince and nedit). However, in the introduction you say that for evaluating your proposal you used other text editors (kilo, vi and cflow on top of vi and vim). This is confusing and distracts the reader. 
\end{point}

\response{The motivating example is more demonstrative and serves as a conceptual illustration of \FOUNDRY's potential. The motivating example featuring \emph{GEdit, Evince, and NEdit} is intended to provide a broad, illustrative view of \FOUNDRY's capabilities. It aims to show how the proposed approach can be applied to diverse systems, not necessarily the ones used in the formal evaluation.

The text editors (\emph{Kilo, VI, CFlow, VI, and VIM}) mentioned in the introduction are part of a focused set chosen specifically for the formal evaluation. The formal evaluation with specific text editors is designed for a more focused and detailed examination of the transplantation viability and ProdScalpel's performance. These editors were selected based on certain criteria such as  complexity, size and number of features, to rigorously test and demonstrate the effectiveness of \FOUNDRY.}

\changes{}

\begin{point} 
2) The solution is weakly presented. The difference between "foundary" and "prodscalpel" is confusing. After some reads, one can understand that one if the conceptual and the other is the implementation. However, this should be cleared right from the beginning. 
\end{point}

\response{We appreciate the reviewer's feedback regarding the clarity of our solution, specifically the distinction between "Foundry" and "ProdScalpel." We acknowledge the importance of clearly articulating their roles from the outset.

Foundry is the software transplantation approach we propose for the reengineering of individual systems into Software Product Lines (SPLs). It represents the conceptual framework and methodology for systematically extracting, adapting, and combining features from diverse sources to create a product line.

On the other hand, ProdScalpel is the practical realization of Foundry. It is the tool designed to implement and automate the steps outlined by Foundry. ProdScalpel serves as the operational instrument, facilitating the extraction of features from donor systems, their adaptation to fit the host system, and the subsequent generation of a product line.

To provide a clearer narrative, we will enhance the introduction to explicitly introduce Foundry as the software transplantation approach and ProdScalpel as the tool that operationalizes this approach. This clarification aims to eliminate any confusion regarding their respective roles and establish a better understanding for readers.}

\changes{In our proposed approach, Foundry is a conceptual approach for the reengineering of individual systems into SPL. Foundry represents a novel software transplantation approach, providing a systematic means of extracting, adapting, and combining features from diverse sources to construct a product line. This conceptual foundation allows for the generation of SPLs by leveraging features from existing codebases, fostering an automated reengineering process.

ProdScalpel is a practical realization of Foundry for codebases written in C. . It is a tool implemented to automate the procedural steps delineated by Foundry. It can be used to make possible the extraction of features from donor systems, adapting them to integrate with the host system, and ultimately, automating the generation of product lines. As the practical counterpart to Foundry's conceptual underpinnings, ProdScalpel bridges the gap between theory and implementation, providing a tangible means for developers to engage with and execute the reengineering process in an automated manner.}

\begin{point} 
Section 3 is not formally or rigorously described. There is no a single definition along the sections and only descriptive paragraphs are used. 
\end{point}

\response{}

\changes{}

\begin{point} 
Why in Figure 2 system 4 is selected? why P and Q are the "code base" and feature N and O are removed? P and Q are not features that are shared with other systems, are they?
\end{point}

\response{}

\changes{}

\begin{point} 
In addition, the implementation is described as a tool paper and adds no value to rigorously and clearly present your approach/tool. 
\end{point}

\response{}

\changes{}

\begin{point} 
- The title is confusing. It seems that the paper is more about "feature extraction and implantation using software transplantation" and it is not much about SPLE
\end{point}

\response{}

\changes{}

\begin{point} 
In the abstract, the ideas are not clear. More details should be given. What is your solution about? In what is based? Only high level descriptions are given.
\end{point}

\response{}

\changes{}

\begin{point} 
Add a reference to support the first sentence of the 2nd paragraph of Section 1
\end{point}

\response{}

\changes{}

\begin{point} 
The first time that prodscalpel is mentioned is in line 44 (pag 3 of 32) and it is confusing that it is. 
\end{point}

\response{}

\changes{}

\begin{point} 
Fig 1 is in page 4 but the first mention to it is in pag 5 and in another section. This is confusing. 
\end{point}

\begin{point} 
Foundary is described as "an approach" (l 29 p 4). It would be nice to more precisely describe it: process? methodology fragment? tool? what?
\end{point}

\response{}

\changes{}

\begin{point} 
The statement that GNOME is a natural candidate for SPL is quite strong! (l 9, p5)
\end{point}
\response{}

\changes{}

\end{letter}
\end{document}
